{"meta":{"title":"小毛驴技术空间","subtitle":"孤舟蓑笠翁，独钓寒江雪。","description":"千山鸟飞绝，万径人踪灭。孤舟蓑笠翁，独钓寒江雪。","author":"等待-希望","url":"https://piggsoft.com"},"pages":[{"title":"404","date":"2017-06-10T20:14:00.000Z","updated":"2020-10-16T02:38:04.064Z","comments":true,"path":"404.html","permalink":"https://piggsoft.com/404.html","excerpt":"","text":"小毛驴的技术空间"},{"title":"about","date":"2017-01-02T15:25:31.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"about/index.html","permalink":"https://piggsoft.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-01-02T12:19:42.000Z","updated":"2020-10-16T02:38:04.068Z","comments":false,"path":"categories/index.html","permalink":"https://piggsoft.com/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-01-02T12:18:47.000Z","updated":"2020-10-16T02:38:04.072Z","comments":false,"path":"tags/index.html","permalink":"https://piggsoft.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开源文档-翻译分享","slug":"开源文档-翻译分享","date":"2019-09-25T15:19:00.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"2019/09/25/开源文档-翻译分享/","link":"","permalink":"https://piggsoft.com/2019/09/25/开源文档-翻译分享/","excerpt":"","text":"官方文档都是英文的，看不懂怎么办？优质的文档零碎的散落在网络的各个角落，好难找怎么办？现在有这样一个github仓库，旨在维护一个目录，集合各个优秀的IT技术书籍和技术书籍翻译，方便大家进行检索。不过这个项目还需要大家的共同努力，个人的接触面有限，不能接触到所有的优秀书籍和书籍翻译。现在我们需要并且期待你的加入，来完善这个目录。Github 地址","categories":[{"name":"文档","slug":"文档","permalink":"https://piggsoft.com/categories/文档/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://piggsoft.com/tags/翻译/"},{"name":"Spring","slug":"Spring","permalink":"https://piggsoft.com/tags/Spring/"},{"name":"Spring boot 教程","slug":"Spring-boot-教程","permalink":"https://piggsoft.com/tags/Spring-boot-教程/"}]},{"title":"PKI体系（三）-EJBCA安装","slug":"PKI体系（三）-EJBCA安装","date":"2018-07-11T14:17:24.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"2018/07/11/PKI体系（三）-EJBCA安装/","link":"","permalink":"https://piggsoft.com/2018/07/11/PKI体系（三）-EJBCA安装/","excerpt":"EJBCA是一个全功能的CA系统软件，它基于J2EE技术，并提供了一个强大的、高性能并基于组件的CA。EJBCA兼具灵活性和平台独立性，能够独立使用，也能和任何J2EE应用程序集成。","text":"EJBCA是一个全功能的CA系统软件，它基于J2EE技术，并提供了一个强大的、高性能并基于组件的CA。EJBCA兼具灵活性和平台独立性，能够独立使用，也能和任何J2EE应用程序集成。 特点 特性： LGPL开源许可; 建立在J2EE 1.3（EJB2.0）规范之上; 灵活的、基于组件的体系结构; 多级CA 多个CA和多级CA，在一个EJBCA实例中建立一个或者多个完整的基础设施单独运行，或者在任何J2EE应用中集成它; 简单的安装和配置 强大的基于Web的管理界面，并采用了高强度的鉴别算法 支持基于命令行的管理，并支持脚本等功能 支持个人证书申请或者证书的批量生产 服务器和客户端证书能够采用PKCS12, JKS或者PEM格 式导出 支持采用Netscape, Mozilla, IE等浏览器直接进行证书申请 支持采用开放API和工具通过其它应用程序申请证书 由RA添加的新用户可以通过email进行提醒 对于新用户验证可以采用随机或者手工的方式生成密码 支持硬件模块，来集成硬件签发系统（例如智能卡） 支持SCEP 支持用特定用户权限和用户组的方式来进行多极化管理 对不同类型和内容的证书可以进行证书配置 对不同类型的用户可以进行实体配置 遵循X509和PKIX(RFC3280)标准 支持CRL 完全支持OCSP，包括AIA扩展 CRL生成和基于URL的CRL分发点遵循RFC3280，可以在任何SQL数据库中存储证书和CRL（通过应用服务器来处 理）。 可选的多个发布器，以用来在LDAP中 发布证书和CRL 支持用来为指定用户和证书来恢复私钥的密钥恢复模块 基于组件的体系结构，用来发布证书和CRL到不 同的目的地 基于组件的体系结构，用来在发布证书时采用多种实体授权方法 容易集成到大型应用程序中，并为集成到业务流程进行了优化 EJBCA完 全采用Java编写，能够在任何采用J2EE服 务器的平台上运行。开发和测试是在Linux和Windows上 进行的。 安装前的准备 JDK1.8 apache-ant-1.9.11-bin Wildfly-12.0.0.Final ejbca_ce_6_10_1_2 mysql-connector-java-5.1.46.jar MySQL Centos 7 (也可是其他系统) 将其中的Wildfly，ejbca_ce_6_10_1_2，mysql-connector-java-5.1.46.jar放到同一个目录下，比如/opt/ca Mysql建表在mysql中新建一个表对应EJBCA的数据 12CREATE DATABASE ejbcatest CHARACTER SET utf8 COLLATE utf8_general_ci;GRANT ALL PRIVILEGES ON ejbcatest.* TO &apos;ejbca&apos;@&apos;%&apos; IDENTIFIED BY &apos;ejbca&apos;; 系统准备 安装JDK 安装ant 解压ant unzip apache-ant-1.9.11-bin.zip 配置path vim /etc/profile, 在文件末尾添加export PATH=&quot;/opt/apache-ant-1.9.11/bin:$PATH&quot; 编译生效source /etc/profile 检查ant是否成功安装ant -version 为EJBCA新建用户 12adduser capasswd ca 将安装包的所有者改成ca 1234chown ca:ca /opt/cachown ca:ca /opt/ca/wildfly-12.0.0.Final.zipchown ca:ca /opt/ca/ejbca_ce_6_10_1_2.zipchown ca:ca /opt/ca/mysql-connector-java-5.1.46.jar 安装 切换用户 su - ca 解压Wildfly unzip /opt/ca/wildfly-12.0.0.Final.zip 修改Wildfly运行配置文件 vim wildfly-12.0.0.Final/bin/standalone.conf 找到53行 将改行注释掉#JAVA_OPTS=&quot;-Xms64m -Xmx512m -XX:MetaspaceSize=96M -XX:MaxMetaspaceSize=256m -Djava.net.preferIPv4Stack=true&quot; 在该行下面加入一行JAVA_OPTS=&quot;-Xms2048m -Xmx2048m -Djava.net.preferIPv4Stack=true&quot; 保存，退出 启动Wildfly./wildfly-12.0.0.Final/bin/standalone.sh 对Wildfly进行配置 启动客户端./wildfly-12.0.0.Final/bin/jboss-cli.sh -c。出现如下字符即进入成功 [standalone@localhost:9990 /] 配置数据源 12345module add --name=com.mysql --resources=/opt/ca/mysql-connector-java-5.1.46.jar --dependencies=javax.api,javax.transaction.api/subsystem=datasources/jdbc-driver=mysql:add(driver-name=\"mysql\",driver-module-name=\"com.mysql\",driver-xa-datasource-class-name=com.mysql.jdbc.Driver)data-source add --name=ejbcads --driver-name=\"mysql\" --connection-url=\"jdbc:mysql://127.0.0.1:3306/ejbcatest\" --jndi-name=\"java:/EjbcaDS\" --use-ccm=true --driver-class=\"com.mysql.jdbc.Driver\" --user-name=\"username\" --password=\"password\" --validate-on-match=true --background-validation=false --prepared-statements-cache-size=50 --share-prepared-statements=true --min-pool-size=5 --max-pool-size=150 --pool-prefill=true --transaction-isolation=TRANSACTION_READ_COMMITTED --check-valid-connection-sql=\"select 1;\" 上面的命令和后续的配置命令都需要一条一条执行。注意替换--connection-url=&quot;jdbc:mysql://127.0.0.1:3306/ejbcatest&quot;，--user-name=&quot;username&quot;，--password=&quot;password&quot; 配置Wildfly远程调用 12345/subsystem=remoting/http-connector=http-remoting-connector:remove/subsystem=remoting/http-connector=http-remoting-connector:add(connector-ref=\"remoting\",security-realm=\"ApplicationRealm\")/socket-binding-group=standard-sockets/socket-binding=remoting:add(port=\"4447\")/subsystem=undertow/server=default-server/http-listener=remoting:add(socket-binding=remoting):reload 输入完成，需等待Wildfly reload完成，可用命令:read-attribute(name=server-state)来进行检查。如果出现如下信息即代表reload成功。 1234&#123; \"outcome\" =&gt; \"success\", \"result\" =&gt; \"running\"&#125; 配置Wildfly log 1234/subsystem=logging/logger=org.ejbca:add/subsystem=logging/logger=org.ejbca:write-attribute(name=level, value=DEBUG)/subsystem=logging/logger=org.cesecore:add/subsystem=logging/logger=org.cesecore:write-attribute(name=level, value=DEBUG) 关闭jboos-cli 对ejbca进行配置 解压文件，unzip ejbca_ce_6_10_1_2.zip 修改ejbca.properties 文件 cp ejbca_ce_6_10_1_2/conf/ejbca.properties.sample ejbca_ce_6_10_1_2/conf/ejbca.properties vim ejbca_ce_6_10_1_2/conf/ejbca.properties 设置 appserver.home 的值(就是应用服务器的安装位置,对于我们来说是 /opt/ca/wildfly-10.0.0.Final)， 最终结果appserver.home=/opt/ca/wildfly-12.0.0.Final 修改web.properties文件 cp ejbca_ce_6_10_1_2/conf/web.properties.sample ejbca_ce_6_10_1_2/conf/web.properties vim ejbca_ce_6_10_1_2/conf/web.properties 设置CA的超级管理员的证书密码,以及给应用服务器生成的服务器端证书的证书密码,和CA的truststory的密码等,这些密码的设置我们可以根据需要设置,或者保持默认的配置,需要注意的是httpsserver.hostname,这个要和后边的alias相对应,我的ip地址为 147.128.105.149,那这里我们设置为147.128.105.149. 最终修改，httpsserver.hostname=127.0.0.1 修改database.properties cp ejbca_ce_6_10_1_2/conf/database.properties.sample ejbca_ce_6_10_1_2/conf/database.properties vim ejbca_ce_6_10_1_2/conf/database.properties 实际上只要使用wildfly的数据源即可 。把datasource.jndi-name=EjbcaDS的注释取消， 还要把 数据库类型database.name=mysql这个注释也要放开。否则安装出错，会执行h2数据库的库表安装脚本。 修改install.properties cp ejbca_ce_6_10_1_2/conf/install.properties.sample ejbca_ce_6_10_1_2/conf/install.properties vim ejbca_ce_6_10_1_2/conf/install.properties 设置CA的名称,加密方式等，建议保持默认即可。 ejbca打包部署 1234cd /opt/ejbca_ce_6_5.0.5/ant clean deployearant runinstallant deploy-keystore 去除Wildfly当前的HTTPS和TLS配置，需要使用./wildfly-12.0.0.Final/bin/jboss-cli.sh -c 1234/subsystem=undertow/server=default-server/http-listener=default:remove/subsystem=undertow/server=default-server/https-listener=https:remove/socket-binding-group=standard-sockets/socket-binding=http:remove/socket-binding-group=standard-sockets/socket-binding=https:remove 配置TLS 配置外部可访问 123456789/interface=http:add(inet-address=\"0.0.0.0\")/interface=httpspub:add(inet-address=\"0.0.0.0\")/interface=httpspriv:add(inet-address=\"0.0.0.0\")/socket-binding-group=standard-sockets/socket-binding=http:add(port=\"8080\",interface=\"http\")/socket-binding-group=standard-sockets/socket-binding=httpspriv:add(port=\"8443\",interface=\"httpspriv\")/socket-binding-group=standard-sockets/socket-binding=httpspub:add(port=\"8442\", interface=\"httpspub\")/subsystem=undertow/server=default-server/http-listener=http:add(socket-binding=http)/subsystem=undertow/server=default-server/http-listener=http:write-attribute(name=redirect-socket, value=\"httpspriv\"):reload 配置端口绑定 1234/core-service=management/security-realm=SSLRealm:add()/core-service=management/security-realm=SSLRealm/server-identity=ssl:add(keystore-path=\"$&#123;jboss.server.config.dir&#125;/keystore/keystore.jks\", keystore-password=\"serverpwd\", alias=\"127.0.0.1\")/core-service=management/security-realm=SSLRealm/authentication=truststore:add(keystore-path=\"$&#123;jboss.server.config.dir&#125;/keystore/truststore.jks\", keystore-password=\"changeit\"):reload 其中keystore-password=&quot;serverpwd&quot;对应web.properties里面的httpsserver.password。alias=&quot;127.0.0.1&quot;对应web.properties里面的httpsserver.hostname 重启wildfly:shutdown(restart=true),等待重启完毕 配置tls 12345/subsystem=undertow/server=default-server/https-listener=httpspriv:add(socket-binding=httpspriv, security-realm=\"SSLRealm\", verify-client=REQUIRED)/subsystem=undertow/server=default-server/https-listener=httpspriv:write-attribute(name=max-parameters, value=\"2048\")/subsystem=undertow/server=default-server/https-listener=httpspub:add(socket-binding=httpspub, security-realm=\"SSLRealm\")/subsystem=undertow/server=default-server/https-listener=httpspub:write-attribute(name=max-parameters, value=\"2048\"):reload 配置编码等其他重要配置 1234567/system-property=org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH:add(value=true)/system-property=org.apache.catalina.connector.CoyoteAdapter.ALLOW_BACKSLASH:add(value=true)/system-property=org.apache.catalina.connector.URI_ENCODING:add(value=\"UTF-8\")/system-property=org.apache.catalina.connector.USE_BODY_ENCODING_FOR_QUERY_STRING:add(value=true)/subsystem=webservices:write-attribute(name=wsdl-host, value=jbossws.undefined.host)/subsystem=webservices:write-attribute(name=modify-wsdl-address, value=true):reload 重启wildfly:shutdown(restart=true),等待重启完毕 访问http://127.0.0.1:8080/ejbca进行验证 下载管理员证书，将/opt/ca/ejbca_ce_6_10_1_2/p12下的superadmin.p12拷贝到本地，对证书进行安装 访问https://127.0.0.1:8443/ejbca进行验证 注：所有的ip需要换成对应的ip或者域名","categories":[{"name":"安全","slug":"安全","permalink":"https://piggsoft.com/categories/安全/"}],"tags":[{"name":"PKI","slug":"PKI","permalink":"https://piggsoft.com/tags/PKI/"},{"name":"EJBCA","slug":"EJBCA","permalink":"https://piggsoft.com/tags/EJBCA/"},{"name":"安全","slug":"安全","permalink":"https://piggsoft.com/tags/安全/"}]},{"title":"PKI体系（二）-Https&双端认证","slug":"PKI体系（二）-Https&双端认证","date":"2018-07-11T09:17:24.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"2018/07/11/PKI体系（二）-Https&双端认证/","link":"","permalink":"https://piggsoft.com/2018/07/11/PKI体系（二）-Https&双端认证/","excerpt":"超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 Https协议默认支持双向认证，只是一般浏览器-服务器架构下不会进行开启。","text":"超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。 Https协议默认支持双向认证，只是一般浏览器-服务器架构下不会进行开启。 SSL/TLS协议传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如Google、Facebook等也以这个协议来创建安全连接，发送数据。目前已成为互联网上保密通信的工业标准。 SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会话密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。 TLS协议采用C/S架构模型，用于在两个应用程序间透过网络创建起安全的连接，防止在交换数据时受到窃听及篡改。 TLS协议的优势是与高层的应用层协议（如HTTP、FTP、Telnet等）无耦合。应用层协议能透明地运行在TLS协议之上，由TLS协议进行创建加密通道需要的协商和认证。应用层协议传送的数据在通过TLS协议时都会被加密，从而保证通信的私密性。 TLS协议是可选的，必须配置客户端和服务器才能使用。主要有两种方式实现这一目标：一个是使用统一的TLS协议通信端口（例如：用于HTTPS的端口443）；另一个是客户端请求服务器连接到TLS时使用特定的协议机制（例如：邮件、新闻协议和STARTTLS）。一旦客户端和服务器都同意使用TLS协议，他们通过使用一个握手过程协商出一个有状态的连接以传输数据[1]。通过握手，客户端和服务器协商各种参数用于创建安全连接： * 当客户端连接到支持TLS协议的服务器要求创建安全连接并列出了受支持的密码组合（加密密码算法和加密哈希函数），握手开始。 * 服务器从该列表中决定加密和散列函数，并通知客户端。 * 服务器发回其数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的公钥。 * 客户端确认其颁发的证书的有效性。 * 为了生成会话密钥用于安全连接，客户端使用服务器的公钥加密随机生成的密钥，并将其发送到服务器，只有服务器才能使用自己的私钥解密。 * 利用随机数，双方生成用于加密和解密的对称密钥。这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭。如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接。 SSL&amp;TLS原理协议组成协议分为三个部分 握手协议（Handshake protocol） 记录协议（Record protocol） 警报协议（Alert protocol） 握手协议握手协议是客户机和服务器用SSL连接通信时使用的第一个子协议，握手协议包括客户机与服务器之间的一系列消息。SSL中最复杂的协议就是握手协议。该协议允许服务器和客户机相互验证，协商加密和MAC算法以及保密密钥，用来保护在SSL记录中发送的数据。握手协议是在应用程序的数据传输之前使用的。 握手协议数据格式每个握手协议包含以下3个字段 Type：表示10种消息类型之一 Length：表示消息长度字节数 Content：与消息相关的参数 握手协议流程握手协议分为4个阶段 建立安全能力 服务器鉴别与密钥交换 客户机鉴别与密钥交换 完成 阶段1：建立安全能力SSL握手的第一阶段启动逻辑连接，建立这个连接的安全能力。首先客户机向服务器发出client hello消息并等待服务器响应，随后服务器向客户机返回server hello消息，对client hello消息中的信息进行确认。ClientHello 客户发送CilentHello信息，包含如下内容： 客户端可以支持的SSL最高版本号 一个用于生成主秘密的32字节的随机数。（等会介绍主秘密是什么） 一个确定会话的会话ID。 一个客户端支持的加密算法列表。 一个客户端可以可以支持的压缩算法列表 ServerHello 服务器用ServerHello信息应答客户，包括下列内容： 一个SSL版本号。取客户端支持的最高版本号和服务端支持的最高版本号中的较低者。 一个用于生成主秘密的32字节的随机数。（客户端一个、服务端一个） 会话ID 从客户端的密码套件列表中选择的一个加密算法 从客户端的压缩方法的列表中选择的压缩方法 阶段2：服务器鉴别和密钥交换服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步： 证书：服务器将数字证书和到根CA整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。 服务器密钥交换（可选）：这里视密钥交换算法而定 证书请求（可选）：服务端可能会要求客户自身进行验证。 服务器握手完成：第二阶段的结束，第三阶段开始的信号 服务器密钥交换：1 和 2是基于密钥交换方法的。SSL中密钥交换算法有6种：无效（没有密钥交换）、RSA、匿名Diffie-Hellman、暂时Diffie-Hellman、固定Diffie-Hellman、Fortezza。在阶段1过程客户端与服务端协商的过程中已经确定使哪种密钥交换算法。如果协商过程中确定使用RSA交换密钥，那么过程如下图： 阶段3：客户机鉴别和密钥交换客户机启动SSL握手第3阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3步： 证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在Tomcat中可以配置强制客户端证书认证。（服务器端请求了客户端证书才会有此步骤） 客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。 证书验证（可选），对预备秘密和随机数进行签名，证明拥有（1）证书的公钥。（服务器端请求了客户端证书才会有此步骤） 阶段4：完成握手完成后，客户端和服务器端后面的信息使用主密钥进行对称加/解密 HttpsHTTP协议和安全协议同属于应用层（OSI模型的最高层），具体来讲，安全协议工作在HTTP之下，运输层之上：安全协议向运行HTTP的进程提供一个类似于TCP的Socket，供进程向其中注入报文，安全协议将报文加密并注入运输层Socket；或是从运输层获取加密报文，解密后交给对应的进程。严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。 HTTPS报文中的任何东西都被加密，包括所有报头和荷载。除了可能的选择密文攻击（参见限制小节）之外，一个攻击者所能知道的只有在两者之间有一连接这一事实。","categories":[{"name":"安全","slug":"安全","permalink":"https://piggsoft.com/categories/安全/"}],"tags":[{"name":"PKI","slug":"PKI","permalink":"https://piggsoft.com/tags/PKI/"},{"name":"EJBCA","slug":"EJBCA","permalink":"https://piggsoft.com/tags/EJBCA/"},{"name":"安全","slug":"安全","permalink":"https://piggsoft.com/tags/安全/"}]},{"title":"PKI体系（一）--PKI介绍","slug":"PKI体系（一）-PKI介绍","date":"2018-07-11T00:15:23.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"2018/07/11/PKI体系（一）-PKI介绍/","link":"","permalink":"https://piggsoft.com/2018/07/11/PKI体系（一）-PKI介绍/","excerpt":"公开密钥基础建设（英语：Public Key Infrastructure，缩写：PKI），又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。 密码学上，公开密钥基础建设借着数字证书认证机构(Certificate Authority，CA)将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防抵赖。 可信赖的第三者（Trusted third party，TTP）也常被用来指证书中心。PKI有时被错误地拿来代表公开密钥密码学或公开密钥算法。","text":"公开密钥基础建设（英语：Public Key Infrastructure，缩写：PKI），又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。 密码学上，公开密钥基础建设借着数字证书认证机构(Certificate Authority，CA)将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防抵赖。 可信赖的第三者（Trusted third party，TTP）也常被用来指证书中心。PKI有时被错误地拿来代表公开密钥密码学或公开密钥算法。 历史1976年Whitfield Diffie、Martin Hellman|Hellman、Ron Rivest、Adi Shamir和Leonard Adleman等人相继公布了安全密钥交换与非对称密钥算法后，整个通信方式为之改变。随着高速电子数字通信的发展，用户对安全通信的需求越来越强。 密码协议在这种诉求下逐渐发展，造就新的密码原型。全球互联网发明与扩散后，认证与安全通信的需求也更加严苛。光商务理由便足以解释一切。时在网景工作的Taher ElGamal等人发展出传输安全层协议，包含了密钥创建、服务器认证等。公开密钥基础建设的架构因此浮现。 厂商和企业家察觉了其后的广大市场，开始设立新公司并启动法律认知与保护。美国律师协会项目发行了一份对公开密钥基础建设操作的可预见法律观点的详尽分析，随后，多个美国州政府与其他国家的司法单位开始制定相关法规。消费者团体等则提出对隐私、访问、可靠性的质疑，也被列入司法的考虑中。 被制定的法规实有不同，将公开密钥基础建设的机制转换成商务操作有实际上的问题，远比许多先驱者所想的缓慢。 21世纪的前几年才慢慢发觉，密码工程没那么容易被设计与实践，某些存在的标准某方面甚至是不合宜的。 公开密钥基础建设的厂商发现了一个市场，但并非九零年代中期所预想的那个市场，这个市场发展得缓慢而且以不同的方式前进。公开密钥基础建设并未解决所期待的问题，某些厂商甚至退出市场。公开密钥基础建设最成功的地方是在政府部门，目前最大的公开密钥基础建设是美国防卫信息系统局 （Defense Information Systems Agency，DISA）的共同访问卡（Common access Cards）方案。 PKI组成 Certificate Authority(CA) 证书颁发机构(or系统)，CA是PKI的基础，它管理着证书的整个生命周期，其作用包括：发放证书，规定证书有效期，废弃不良信用证书。 Registration Authority(RA) 证书注册，登记机构(or系统)，RA提供一个用户和CA之前的桥梁，用户通过RA进行证书的申请，RA获取用户的身份信息并确认用户的信息，向CA提出证书申请。它接受用户的注册申请，审查用户的申请资格，并决定是否同意CA给其签发数字证书。注册机构并不给用户签发证书，而只是对用户进行资格审查。因此，RA可以设置在直接面对客户的业务部门，如银行的营业部、机构认识部门等。当然，对于一个规模较小的PKI应用系统来说，可把注册管理的职能由认证中心CA来完成，而不设立独立运行的RA。但这并不是取消了PKI的注册功能，而只是将其作为CA的一项功能而已。PKI国际标准推荐由一个独立的RA来完成注册管理的任务，可以增强应用系统的安全。 这里的用户是指将要申请证书的客户，可以是个人，集团或团体，政府机构等。 Validation Authority(VA) 证书验证机构(or系统)。在PKI中，VA是一个实体，它根据X.509标准和RFC 5280（第69页）中描述的机制提供用于验证数字证书有效性的服务。 VA一般由第三方来提供，PKI对VA没有强制要求，可以是Nginx， Tomcat等。 证书存储-证书和私钥存储位置 证书管理中心-管理证书的申请，下发，存储 机构可信度-PKI系统就本身的证书进行说明，其目的是允许外部分析PKI的可信度。 PKI认证方法 认证机构","categories":[{"name":"安全","slug":"安全","permalink":"https://piggsoft.com/categories/安全/"}],"tags":[{"name":"PKI","slug":"PKI","permalink":"https://piggsoft.com/tags/PKI/"},{"name":"EJBCA","slug":"EJBCA","permalink":"https://piggsoft.com/tags/EJBCA/"},{"name":"安全","slug":"安全","permalink":"https://piggsoft.com/tags/安全/"}]},{"title":"Linux上使用定时任务Crontab","slug":"2017-06-10-Linux-使用定时任务Crontab","date":"2017-06-10T18:40:20.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"2017/06/10/2017-06-10-Linux-使用定时任务Crontab/","link":"","permalink":"https://piggsoft.com/2017/06/10/2017-06-10-Linux-使用定时任务Crontab/","excerpt":"使用linux的定时器，在服务器上面定时执行某些任务，比如时间同步，比如Hexo的定时更新和生成","text":"使用linux的定时器，在服务器上面定时执行某些任务，比如时间同步，比如Hexo的定时更新和生成 安装检查是否安装crontab在命令行中输入如下命令，观察是否安装crontab1crontab -e 安装crontab如果没有安装，使用yum来进行安装，在命令行中输入下令命令来安装1yum install vixie-cron crontabs 其中vixie-cron软件包是cron的主程序，crontabs软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。 启动crontabcron 是linux的内置服务，但它不自动起来，可以用以下的方法启动、关闭这个服务：12345service crond start //启动服务service crond stop //关闭服务service crond restart //重启服务service crond reload //重新载入配置service crond status //查看crontab服务状态 加入开机启动命令行中输入如下命令，在crond加入开机启动1chkconfig --level 35 crond on 使用cron表达式linux上cron表达式为5位，分别代表 第一位 第二位 第三位 第四位 第五位 分钟 小时 天 月 周 命令使用方法 命令行中输入crontab -e 在弹出的文本中输入 * * * * * * command 比如 */1 * * * * echo &quot;hello world&quot; &gt; /log/corn_test 查看现有的cron配置 在命令行中输入crontab -l 直接查看文件vim /var/spool/cron/root,其中最后的root为当前的用户名","categories":[{"name":"工具","slug":"工具","permalink":"https://piggsoft.com/categories/工具/"}],"tags":[{"name":"定时器","slug":"定时器","permalink":"https://piggsoft.com/tags/定时器/"},{"name":"cron","slug":"cron","permalink":"https://piggsoft.com/tags/cron/"}]},{"title":"常用文档目录整理","slug":"2017-06-10-常用文档目录整理","date":"2017-06-10T14:03:52.000Z","updated":"2020-10-16T02:38:04.068Z","comments":true,"path":"2017/06/10/2017-06-10-常用文档目录整理/","link":"","permalink":"https://piggsoft.com/2017/06/10/2017-06-10-常用文档目录整理/","excerpt":"本目录旨在集合各个优秀IT书籍&amp;API翻译&amp;官方Docs翻译。这个仓库不产出书籍，只是将网上流传着的书籍&amp;书籍翻译集合在一起，供大家检索学习。在此先感谢那些为我们提供书籍和书籍翻译的作者，因为有他们，我们才能更好学习，了解，使用技术。下面的列表将按字母的升序排列","text":"本目录旨在集合各个优秀IT书籍&amp;API翻译&amp;官方Docs翻译。这个仓库不产出书籍，只是将网上流传着的书籍&amp;书籍翻译集合在一起，供大家检索学习。在此先感谢那些为我们提供书籍和书籍翻译的作者，因为有他们，我们才能更好学习，了解，使用技术。下面的列表将按字母的升序排列 分类 前端 Android Elasticsearch Docker Git Go IOS Java Linux Python Redis Rx/RxJava TensorFlow 其他 前端 Material Design 中文协同翻译 知识月刊 JS函数式编程指南 React 入门教程 前端工程师手册 TypeScript Handbook（中文版） Webpack 中文指南 ECMAScript 6 入门 ECMAScript 5 入门 七天学会NodeJS lodash juicer Angular 4.0中文文档 zeptojs Redux 中文文档 Vue.js 教程 Vue2.0 教程 vuex 教程 vux 教程 ionic 教程 JavaScript教程 HTML教程 CSS教程 CSS参考手册 jQuery教程 Foundation教程 CSS3教程 HTML DOM 教程 JavaScript 参考手册 React 教程 Bootstrap 教程 AngularJS 教程 DTD 教程 jQuery UI 教程 jQuery EasyUI 教程 Ajax 教程 Highcharts 教程 AppML 教程 VBScript 教程 jQuery Mobile 教程 SVG 教程 浏览器 HTML 参考手册 正则表达式 JSON 教程 Android Android开发技术前线 ( android-tech-frontier ) Android Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文. Elasticsearch Elasticsearch权威指南（中文版） ELKstack 中文指南 Docker Docker —— 从入门到实践 Git Pro Git 中文版 Go Go 语言圣经 中文版 Go Web 编程 IOS iOS-Core-Animation-Advanced-Techniques 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译） 翻译、开发心得或学习笔记 Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译 Articles for objccn.io. objc.io的完整、准确、优雅的中文翻译版本 一个定期翻译国外iOS优质的技术、开源库、软件架构设计、测试等文章的开源项目 Developing iOS 9 Apps with Swift 字幕简体中文翻译项目 《The Swift Programming Language》中文版 KKBOX iOS/Mac OS X 基礎開發教材 Swift 教程 Java Thinking in Java (Java 编程思想) stackoverflow上Java相关回答Top100整理翻译 Spring Boot Reference Guide中文翻译 -《Spring Boot参考指南》 中文翻译《Spring Framework 4.x参考文档》 《Netty 4.x 用户指南》 JetBrains IDE/Android Studio 翻译插件 Spring MVC 4.2.4 RELEASE 中文文档完整翻译稿 Gradle User Guide 中文版 Linux 鸟哥的Linux私房菜：基础学习篇 第四版 Linux中国翻译项目 Shell 编程范例 Python 零基础学Python python document stackoverflow-py-top-qa Redis 《Redis Command Reference》全文的中文翻译版 Redis开发运维实践指南 Rx/RxJava Rx和RxJava文档中文翻译项目 RxJava Essentials 中文翻译版 TensorFlow TensorFlow 官方文档中文版 其他 掘金翻译计划，翻译掘金上优质的英文文章 What-happens-when 的中文翻译 程序员的自我修养 编程之法：面试和算法心得","categories":[{"name":"文档","slug":"文档","permalink":"https://piggsoft.com/categories/文档/"}],"tags":[{"name":"Java Document","slug":"Java-Document","permalink":"https://piggsoft.com/tags/Java-Document/"}]},{"title":"TCP通讯详解及实战","slug":"2017-01-03-TCP通讯详解及实战","date":"2017-01-03T14:41:19.000Z","updated":"2020-10-16T02:38:04.064Z","comments":true,"path":"2017/01/03/2017-01-03-TCP通讯详解及实战/","link":"","permalink":"https://piggsoft.com/2017/01/03/2017-01-03-TCP通讯详解及实战/","excerpt":"日常开发，测试过程中，特别是在压力测试过程中，用netstat -nat查看，发现客户端出现大量SYN_SENT状态, 服务端出现大量SYN_RCVD状态连接,下面我们一起看下 为什么会有这些状态？ 出现这些状态原因是什么？","text":"日常开发，测试过程中，特别是在压力测试过程中，用netstat -nat查看，发现客户端出现大量SYN_SENT状态, 服务端出现大量SYN_RCVD状态连接,下面我们一起看下 为什么会有这些状态？ 出现这些状态原因是什么？ TCP协议模型 IP和端口解决了文章最开始提到的定位的问题。IP在互联网中能唯一标识一台计算机，是每一台计算机的唯一标识（身份证）；网络编程是和远程计算机的通信，所以必须先能定位到远程计算机；IP帮助解决此问题；一台计算机中可能有很多进程，具体和哪一个进程进行通信，这就得靠端口来识别； TCP和UDP协议 TCP是Tranfer Control Protocol的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据目的地的时间以及内容的正确性都是不能被保证的传输，双方都可以进行发送或接收操作。 UDP是User Datagram Protocol的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达。 比较： UDP： 每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。 UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。 UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方 TCP： 面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。 TCP传输数据大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。 TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。 应用数据分割成TCP认为最适合发送的数据块。这部分是通过“MSS”（最大数据包长度）选项来控制的，通常这种机制也被称为一种协商机制，MSS规定了TCP传往另一端的最大数据块的长度。值得注意的是，MSS只能出现在SYN报文段中，若一方不接收来自另一方的MSS值，则MSS就定为536字节。一般来讲，在不出现分段的情况下，MSS值还是越大越好，这样可以提高网络的利用率。 重传机制。设置定时器，等待确认包。 对首部和数据进行校验。 TCP对收到的数据进行排序，然后交给应用层。 TCP的接收端丢弃重复的数据。 TCP还提供流量控制。（通过每一端声明的窗口大小来提供的） TCP状态机 TCP状态图 连接建立 第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机； 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。 完成三次握手，主机A与主机B开始传送数据。 连接关闭, 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。附上另一张图：!()[3.png] TCP状态 CLOSED： 表示初始状态。 LISTEN： 表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 SYN_RCVD： 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 SYN_SENT： 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 ESTABLISHED：表示连接已经建立。 FIN_WAIT_1： 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 TIME_WAIT： 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSE_WAIT： 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK： 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 CLOSING： 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接 通讯类型 短连接 连接 -&gt; 数据传输 -&gt; 关闭连接 长连接，要求长连接在没有数据通信时，定时发送数据包，以维持连接状态，短连接在没有数据传输时直接关闭就行了 长连接需要心跳包维护连接状态 连接-&gt;数据传输-&gt;保持连接-&gt;数据传输-&gt;保持连接-&gt; …… -&gt;关闭连接 什么时候用长连接，短连接？长连接主要用于在少数客户端与服务端的频繁通信，因为这时候如果用短连接频繁通信常会发生Socket出错，并且频繁创建Socket连接也是对资源的浪费。 但是对于服务端来说，长连接也会耗费一定的资源，需要专门的线程来负责维护连接状态。 同步通讯–报文发送和接收是同步进行，既报文发送后等待接收返回报文。 发送数据之后等待接收返回数据。同步方式一般需要考虑超时问题，即报文发上去后不能无限等待，需要设定超时时间，超过该时间发送方不再等待读返回报文，直接通知超时返回。 异步通讯–报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况： 异步双工：接收和发送在同一个程序中，有两个不同的子进程分别负责发送和接收 异步单工：接收和发送是用两个不同的程序来完成。 日常应用我们通过了解TCP各个状态，可以排除和定位网络或系统故障时大有帮助。 linux查看tcp的状态命令： netstat -nat 查看TCP各个状态的数量 lsof -i:port 可以检测到打开套接字的状况 tcpdump -iany tcp port 9000 对tcp端口为9000的进行抓包 故障排查通过端口监听判断服务启动是否正常netstat –an| grep 8080 例如：提供www服务默认开的是80端口，提供ftp服务默认的端口为21，当提供的服务没有被连接时就处于LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。处于侦听LISTENING状态时，该端口是开放的，等待连接 客户端出现大量SYN_SENT状态 当请求连接时客户端首先要发送同步信号给要访问的机器，此时状态为SYN_SENT，如果连接成功了就变为ESTABLISHED，正常情况下SYN_SENT状态非常短暂 如果发现有很多SYN_SENT出现，那一般有这么几种情况，一是你要访问的服务器网络不好，二是服务端无法建立连接返回ack 服务端出现大量SYN_RCVD状态连接 同理SYN_RCVD状态也是非常短暂的，如果大量出现说明有可能遭到了攻击，或者是客户端网络限制 大量的CLOSE-WAIT状态 被动关闭(passive close)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并进CLOSE_WAIT.如果连接不关闭CLOSE_WAIT持续时间会非常长，如果长时间积累，可能会导致系统资源耗尽 发现系统存在大量TIME_WAIT状态的连接,可以修改内核参数解决，修改TIME_WAIT持续时间","categories":[{"name":"IT","slug":"IT","permalink":"https://piggsoft.com/categories/IT/"}],"tags":[{"name":"TCP IP","slug":"TCP-IP","permalink":"https://piggsoft.com/tags/TCP-IP/"}]},{"title":"跟着独钓翁一起学习spring-boot(一)","slug":"2017-01-03-跟着独钓翁一起学习spring-boot-一","date":"2017-01-03T10:05:41.000Z","updated":"2020-10-16T02:38:04.064Z","comments":true,"path":"2017/01/03/2017-01-03-跟着独钓翁一起学习spring-boot-一/","link":"","permalink":"https://piggsoft.com/2017/01/03/2017-01-03-跟着独钓翁一起学习spring-boot-一/","excerpt":"相关背景Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。","text":"相关背景Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。 多年以来，Spring IO平台饱受非议的一点就是大量的XML配置以及复杂的依赖管理。在去年的SpringOne 2GX会议上，Pivotal的CTO Adrian Colyer回应了这些批评，并且特别提到该平台将来的目标之一就是实现免XML配置的开发体验。Boot所实现的功能超出了这个任务的描述，开发人员不仅不再需要编写XML，而且在一些场景中甚至不需要编写繁琐的import语句。在对外公开的beta版本刚刚发布之时，Boot描述了如何使用该框架在140个字符内实现可运行的web应用，从而获得了极大的关注度，该样例发表在tweet上。 然而，Spring Boot并不是要成为Spring IO平台里面众多“Foundation”层项目的替代者。Spring Boot的目标不在于为已解决的问题域提供新的解决方案，而是为平台带来另一种开发体验，从而简化对这些已有技术的使用。对于已经熟悉Spring生态系统的开发人员来说，Boot是一个很理想的选择，不过对于采用Spring技术的新人来说，Boot提供一种更简洁的方式来使用这些技术。 在追求开发体验的提升方面，Spring Boot，甚至可以说整个Spring生态系统都使用到了Groovy编程语言。Boot所提供的众多便捷功能，都是借助于Groovy强大的MetaObject协议、可插拔的AST转换过程以及内置的依赖解决方案引擎所实现的。在其核心的编译模型之中，Boot使用Groovy来构建工程文件，所以它可以使用通用的导入和样板方法（如类的main方法）对类所生成的字节码进行装饰（decorate）。这样使用Boot编写的应用就能保持非常简洁，却依然可以提供众多的功能 快速开始 访问Spring Initializr 选择构建方式Maven，Spring Boot 版本 填写group，artifact 选择所需依赖，如果不记得依赖的名称，可以点击Switch to the full version. 点击Generate Project， 进行下载。 配置运行 接下压缩包，用你熟悉的ide打开项目 删除mvnw，mvnw.cmd文件和 .mvn目录 编写一个Controller 123456789@Controllerpublic class HomeController &#123; @RequestMapping(\"/\") public void hello(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.getWriter().write(\"Hello World\"); &#125;&#125; 运行XXApplication的main方法，访问http://localhost:8080，观看到Hello World，即代表成功。","categories":[{"name":"IT","slug":"IT","permalink":"https://piggsoft.com/categories/IT/"}],"tags":[{"name":"Java Spring Spring-Boot","slug":"Java-Spring-Spring-Boot","permalink":"https://piggsoft.com/tags/Java-Spring-Spring-Boot/"}]},{"title":"Java进行四则运算","slug":"2016-03-15-Java进行四则运算","date":"2016-03-15T00:00:00.000Z","updated":"2020-10-16T02:38:04.064Z","comments":true,"path":"2016/03/15/2016-03-15-Java进行四则运算/","link":"","permalink":"https://piggsoft.com/2016/03/15/2016-03-15-Java进行四则运算/","excerpt":"更加便捷的进行四则运算，且代码足够简单。一般的逻辑是按照正常人的思路来解析，这样难度太大。转换思路和原理，可以参考将中缀表达式转化为后缀表达式","text":"更加便捷的进行四则运算，且代码足够简单。一般的逻辑是按照正常人的思路来解析，这样难度太大。转换思路和原理，可以参考将中缀表达式转化为后缀表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.piggsoft;import java.math.BigDecimal;import java.util.ArrayList;import java.util.List;import java.util.Stack;import java.util.regex.Pattern;public class Arithmetic &#123; //操作符stack private Stack&lt;String&gt; operator = new Stack&lt;String&gt;(); //后缀表达式 private List&lt;String&gt; postFix = new ArrayList&lt;String&gt;(); private Pattern operatorPattern = Pattern.compile(\"[\\\\d\\\\.]\"); private Pattern arithmeticPattern = Pattern.compile(\"[\\\\(\\\\)\\\\+\\\\-/\\\\*]\"); //将中缀表达式换为后缀表达式 public void parse(String s) &#123; s = replace(s); int j = 0; for (int i = 0; i &lt; s.length(); i++) &#123; String temp = s.substring(i, i + 1); if (operatorPattern.matcher(temp).matches()) &#123; continue; &#125; if (arithmeticPattern.matcher(temp).matches()) &#123; j = process(j, i, s, temp); &#125; else if (\"\".equals(temp)) &#123; return; &#125; &#125; if (j &lt; s.length()) &#123; postFix.add(s.substring(j, s.length())); &#125; while (!this.operator.isEmpty()) &#123; postFix.add(operator.pop()); &#125; &#125; private String replace(String s) &#123; return s.replaceAll(\"\\\\s\", \"\"); &#125; private int process(int startIndex, int currentIndex, String str, String word) &#123; if (startIndex != currentIndex) &#123; postFix.add(str.substring(startIndex, currentIndex)); &#125; addOperator(word); startIndex = currentIndex + 1; if (startIndex &gt; str.length()) &#123; startIndex = str.length(); &#125; return startIndex; &#125; public void addOperator(String operator) &#123; if (\"(\".equals(operator)) &#123; &#125; else if (\")\".equals(operator)) &#123; while (!this.operator.isEmpty()) &#123; String temp = this.operator.pop(); if (\"(\".equals(temp)) &#123; break; &#125; else &#123; postFix.add(temp); &#125; &#125; return; &#125; else if (!this.operator.isEmpty()) &#123; while (!this.operator.isEmpty()) &#123; String temp = this.operator.peek(); if (needPop(temp, operator)) &#123; this.postFix.add(this.operator.pop()); &#125; else &#123; break; &#125; &#125; &#125; this.operator.add(operator); &#125; public boolean needPop(String inStackTop, String current) &#123; return getLevel(current.charAt(0)) &lt;= getLevel(inStackTop.charAt(0)); &#125; public int getLevel(char operator) &#123; switch (operator) &#123; case '+': return 1; case '-': return 1; case '*': return 2; case '/': return 2; default: return -1; &#125; &#125; public BigDecimal compute() &#123; Stack&lt;BigDecimal&gt; stack = new Stack&lt;BigDecimal&gt;(); for (int i = 0; i &lt; this.postFix.size(); i++) &#123; if (arithmeticPattern.matcher(postFix.get(i)).matches()) &#123; BigDecimal bd2 = stack.pop(); BigDecimal bd1 = stack.pop(); BigDecimal temp = compute(postFix.get(i).charAt(0), bd1, bd2); stack.add(temp); &#125; else &#123; stack.add(new BigDecimal(postFix.get(i))); &#125; &#125; return stack.pop(); &#125; private BigDecimal compute(char operator, BigDecimal bd1, BigDecimal bd2) &#123; switch (operator) &#123; case '+': return bd1.add(bd2); case '-': return bd1.subtract(bd2); case '*': return bd1.multiply(bd2); case '/': return bd1.divide(bd2);//应当使用bd1.divide(divisor, scale, roundingMode); default: return null; &#125; &#125; public static void main(String[] args) &#123; Arithmetic arithmetic = new Arithmetic(); arithmetic.parse(\"9 + (3 - 1) * 3 + 10 / 2\"); System.out.println(arithmetic.postFix); System.out.println(arithmetic.compute()); arithmetic = new Arithmetic(); arithmetic.parse(\"9 + (3 - 1) * 3 + 10 / 2 + 1000 - 200 - (100 + 5 - 9 / 3)\"); System.out.println(arithmetic.postFix); System.out.println(arithmetic.compute()); arithmetic = new Arithmetic(); arithmetic.parse(\"9 + (3 - 1) * 3 + 10 / 2 + 1000 - 200 - (100 + 5 - 9 / 3)\"); System.out.println(arithmetic.postFix); System.out.println(arithmetic.compute()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://piggsoft.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://piggsoft.com/tags/Java/"},{"name":"Math","slug":"Math","permalink":"https://piggsoft.com/tags/Math/"}]},{"title":"Windows指定部分IP走VPN通道","slug":"2015-05-13-Windows指定部分IP走VPN通道","date":"2015-05-13T00:00:00.000Z","updated":"2020-10-16T02:38:04.064Z","comments":true,"path":"2015/05/13/2015-05-13-Windows指定部分IP走VPN通道/","link":"","permalink":"https://piggsoft.com/2015/05/13/2015-05-13-Windows指定部分IP走VPN通道/","excerpt":"因为工作需要可能要在机器连接公司的VPN，但一般情况下连了VPN就无法连接到外网了，本文主要是讲解如何在Windows上配置，从而让固定ip走VPN，其余走本地网络。","text":"因为工作需要可能要在机器连接公司的VPN，但一般情况下连了VPN就无法连接到外网了，本文主要是讲解如何在Windows上配置，从而让固定ip走VPN，其余走本地网络。 按照正常流程配置好VPN 在vpn连接属性–&gt;网络–&gt;Internet协议版本4–&gt;属性–&gt;高级–&gt;去掉《在远程网络上使用默认网关》；这样做让所有连接都走本地网络连接，不走vpn。 连接vpn，获取vpn分配的ip 输入命令： 1$&gt;ipconfig 结果如下： 12345PPP 适配器 FUIOU VPN 连接: 连接特定的 DNS 后缀 . . . . . . . : IPv4 地址 . . . . . . . . . . . . : 192.168.18.101 子网掩码 . . . . . . . . . . . . : 255.255.255.255 默认网关. . . . . . . . . . . . . : 添加route解析 1route add -p 192.168.8.22 mask 255.255.255.255 192.168.18.101 metric 2 192.168.8.22 –&gt;想要通过vpn访问的ip 192.168.18.101 –&gt; 上面vpn分配的ip 在命令行中加入这个命令。使用下面命令进行测试 ping 192.168.8.22至此配置完成，既可以访问外网，又可以访问192.168.8.22这个VPN地址","categories":[{"name":"IT","slug":"IT","permalink":"https://piggsoft.com/categories/IT/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://piggsoft.com/tags/Windows/"},{"name":"VPN","slug":"VPN","permalink":"https://piggsoft.com/tags/VPN/"}]}]}